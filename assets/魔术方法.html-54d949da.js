import{_ as l,r as i,o as d,c as a,a as o,b as e,d as _,e as r}from"./app-81cf5d26.js";const t={},s={href:"https://www.php.net/manual/zh/language.oop5.magic.php",target:"_blank",rel:"noopener noreferrer"},n=r('<hr><ul><li><code>__construct()</code></li><li><code>__destruct()</code></li><li><code>__call() </code></li><li><code>__callStatic()</code></li><li><code>__get() </code></li><li><code>__set()</code></li><li><code>__isset()</code></li><li><code>__unset()</code></li><li><code>__sleep()</code></li><li><code>__wakeup()</code></li><li><code>__serialize()</code></li><li><code>__unserialize()</code></li><li><code>__toString()</code></li><li><code>__invoke()</code></li><li><code>__set_state() </code></li><li><code>__clone() </code></li><li><code>__debugInfo() </code></li></ul><hr><h3 id="call-和-callstatic" tabindex="-1"><a class="header-anchor" href="#call-和-callstatic" aria-hidden="true">#</a> <code>__call</code> 和 <code>__callStatic</code></h3><p>在对象中调用一个不可访问方法时，<code>__call()</code> 会被调用。 在静态上下文中调用一个不可访问方法时，<code>__callStatic()</code> 会被调用</p><hr><h3 id="sleep-和-wakeup" tabindex="-1"><a class="header-anchor" href="#sleep-和-wakeup" aria-hidden="true">#</a> <code>__sleep()</code> 和 <code>__wakeup()</code></h3><ul><li><code>serialize()</code>函数会检查类中是否存在一个魔术方法 <code>__sleep()</code>。如果存在，该方法会先被调用，然后才执行序列化操作。</li><li><code>unserialize()</code> 会检查是否存在一个 <code>__wakeup()</code> 方法。如果存在，则会先调用 <code>__wakeup</code> 方法，预先准备对象需要的资源。</li></ul><blockquote><p><code>__wakeup()</code> 绕过：php的特性，当序列化后对象的参数列表中成员个数和实际个数不符合时会绕过 `__weakup()</p></blockquote><hr><h3 id="serialize-和-unserialize" tabindex="-1"><a class="header-anchor" href="#serialize-和-unserialize" aria-hidden="true">#</a> <code>__serialize()</code> 和 <code>__unserialize()</code></h3><ul><li><code>serialize() </code>函数会检查类中是否存在一个魔术方法 <code>__serialize()</code> 。如果存在，该方法将在任何序列化之前优先执行。</li></ul><blockquote><p><strong>注意:</strong> 如果类中同时定义了 <code>__serialize()</code> 和 <code>__sleep()</code> 两个魔术方法，则只有 <code>__serialize()</code> 方法会&gt;调用。 <code>__sleep() </code>方法会被忽略掉。如果对象实现了 Serializable 接口，接口的 <code>serialize() </code>方&gt;会被忽略，做为代替类中的 <code>__serialize() </code>方法会被调用。</p></blockquote><ul><li><code>unserialize()</code> 检查是否存在具有名为 <code>__unserialize()</code> 的魔术方法。此函数将会传递从 <code>__serialize()</code> 返回的恢复数组。然后它可以根据需要从该数组中恢复对象的属性。</li></ul><hr><h3 id="tostring" tabindex="-1"><a class="header-anchor" href="#tostring" aria-hidden="true">#</a> <code>__toString()</code></h3><ul><li><code>__toString()</code>方法用于一个类被当成字符串时应怎样回应。例如 <code>echo $obj;</code> 应该显示些什么。</li></ul><hr><h3 id="invoke" tabindex="-1"><a class="header-anchor" href="#invoke" aria-hidden="true">#</a> <code>__invoke()</code></h3><ul><li>当尝试以调用函数的方式调用一个对象时，<code>__invoke()</code> 方法会被自动调用。</li></ul><hr>',21);function h(u,p){const c=i("ExternalLinkIcon");return d(),a("div",null,[o("p",null,[e("#PHP "),o("a",s,[e("PHP: 魔术方法 - Manual"),_(c)]),e(" 魔术方法是一种特殊的方法，当对对象执行某些操作时会覆盖 PHP 的默认操作。")]),n])}const z=l(t,[["render",h],["__file","魔术方法.html.vue"]]);export{z as default};
